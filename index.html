<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> Mine Sweeper </title>
  <style>
    * {
      -khtml-user-select: none;
      -o-user-select: none;
      -moz-user-select: -moz-none;
      -webkit-user-select: none;
      user-select: none;
    }
    
    body {
      font-size: 12px;
      text-align: center;
      font-family: 'Lucida Grande', Verdana, 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Sans Unicode', Geneva, sans-serif;
      background: linear-gradient(to right, ivory, snow);
      /* background: linear-gradient(to right, antiquewhite, beige, cornsilk, ivory, bisque); */
    }
    
    h1 {
      font-size: 3rem;
      font-weight: bolder;
    }
    
    table {
      margin: auto;
      border: 1px solid rgb(127, 127, 127);
    }
    
    td {
      height: 1rem;
      width: 1rem;
      background-color: #ccc;
      border-left: .2rem solid #fafafa;
      border-top: .2rem solid #fafafa;
      border-right: .2rem solid #aaa;
      border-bottom: .2rem solid #aaa;
      font-weight: 900;
      font-size: .8rem;
    }
    
    .clicked {
      border: .2rem solid #e6e1e1;
      background-color: #eee;
      color: #666666;
    }
    
    .mine {
      background-color: #ff0000 !important;
      ;
    }
    
    .mode_area {
      margin: auto;
      border: 1px solid black;
      border-radius: 7px;
      padding: 1rem;
      max-width: fit-content;
    }
    
    .text {
      font-size: 1.2rem;
      font-weight: bolder;
    }
    
    .crimson {
      color: crimson;
    }
    
    .bandera:before {
      font-size: .8rem;
      content: "#";
      animation: fadein .5s;
    }
    
    .duda:before {
      font-size: .8rem;
      content: "?";
      animation: fadein .5s;
    }
    
    #you_lost {
      font-size: 1.7rem;
      font-weight: bolder;
      color: crimson;
      animation: fadein 1s;
    }
    
    #you_won {
      font-size: 1.7rem;
      font-weight: bolder;
      color: cornflowerblue;
      animation: fadein .5s;
    }
    
    @keyframes fadein {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    
    .button {
      padding: 5px 10px;
      font-size: 1.2rem;
      text-align: center;
      cursor: pointer;
      outline: none;
      color: #000000;
      background-color: #e9c581;
      border: none;
      border-radius: 5px;
      box-shadow: 0 6px #999;
    }
    
    .button:hover {
      background-color: #eea333
    }
    
    .button_pressed {
      background-color: #3b3534;
      color: #e9e4e4;
      border: 2px solid coral;
      /* transform: translateY(4px);
        box-shadow: 0 2px #999; */
    }
    
    .border_won {
      border: .3rem solid cornflowerblue;
    }
    
    .border_lost {
      border: .3rem solid red;
    }
  </style>
</head>

<body>
  <h1>Mine Sweeper </h1>
  <h3># : mines
    <!-- &emsp;&emsp; ? : marker -->
  </h3>
  <br>
  <p class="">
    <span id="display_mine_pending" class="text crimson mode_area"></span> &emsp;&emsp;
    <span id="elapsed_time" class="text crimson mode_area">0:00</span>
  </p>
  <br>
  <section id="mine_field"></section>
  <br>
  <section class="mode_area">
    <!-- <div class="text">Mode</div>
    <br>-->
    <button class="button" id="button1" onclick="reset(1)">Easy</button>
    <button class="button" id="button2" onclick="reset(2)">Medium</button>
    <button class="button" id="button3" onclick="reset(3)">Hard</button>
  </section>
  <br>
  <br>
  <section id="you_won"></section>
  <section id="you_lost"></section>
  <section id="error">
    <ul></ul>
  </section>
  <script type="text/javascript">
    var grid_cols = 3
    var grid_rows = 3
    var inicial_mines = 0 //

    const cell = []
    var firstClick = true;
    var stop_clicks = false

    //developer mode
    if (1) {
      reset(1)
    } else {
      create_board()
    }
    //Time variables
    var myInterval = null;
    var seconds = 0
    var minutes = 0;

    //time functions
    function start_timer() {
      myInterval = setInterval(myTimer, 1000);
    }

    function myTimer() {
      if (seconds < 10) {
        seconds = "0" + seconds
      }
      if (seconds > 59) {
        minutes++
        seconds = "00"
      }
      document.getElementById("elapsed_time").innerHTML = minutes + ":" + seconds
      seconds++
    }

    function stop_timer() {
      clearInterval(myInterval);
    }
    /**
     * Lever reset
     * param: integer, changes de level of difficulty
     */
    function reset(level) {
      seconds = 0
      minutes = 0
      document.getElementById("display_mine_pending").innerHTML = 0
      document.getElementById("elapsed_time").innerHTML = "0:00"
      const table = document.getElementById("myTable")
        //console.log("table")
        //console.log(table)
      if (table) table.remove()
      let remove_class = document.getElementsByClassName("button_pressed")
      if (remove_class.length > 0) {
        remove_class[0].classList.remove("button_pressed")
      }
      firstClick = true
      stop_clicks = false
      let button = null;

      if (level == 1) {
        grid_rows = 9
        grid_cols = 9
        inicial_mines = 10
        button = document.getElementById("button1")
      } else if (level == 2) {
        grid_rows = 16
        grid_cols = 16
        inicial_mines = 40
        button = document.getElementById("button2")
      } else if (level == 3) {
        grid_rows = 16
        grid_cols = 30
        inicial_mines = 99
        button = document.getElementById("button3")
      }
      stop_timer()
      create_board(grid_rows, grid_cols)
      button.classList.add("button_pressed")

      display_message("pending", inicial_mines)
      document.getElementById("you_lost").innerHTML = ""
      document.getElementById("you_won").innerHTML = ""
    }

    /**
     * Counts the values of the array "cell"
     */
    function object_counter() {
      let count_flags = 0
      let count_mines = 0
      let count_mine_plus_flags = 0
      let count_clicked = 0
      for (let i = 0; i < grid_rows; i++) {
        for (let j = 0; j < grid_cols; j++) {
          (cell[i][j].mine && cell[i][j].flagged) ? count_mine_plus_flags++ : null;
          (cell[i][j].flagged) ? count_flags++ : null;
          (cell[i][j].mine) ? count_mines++ : null;
          (cell[i][j].clicked) ? count_clicked++ : null;
        }
      }
      display_message("pending", (inicial_mines - count_flags));
      //console.log("grid_rows * grid_cols: " + grid_rows * grid_cols)
      //console.log(count_mines + " m, " + count_flags + " f, " + count_clicked + " c, " + count_mine_plus_flags + " m+f")

      if (count_mine_plus_flags == count_flags && count_flags == count_mines && (count_flags + count_clicked) == (grid_rows * grid_cols) && count_mines != 0) {
        you_win()
      }
    }
    /**
     * Creates the initial board and when changing levels of difficulty
     */
    function create_board() {
      var table = document.createElement("table");
      table.setAttribute("id", "myTable");
      document.getElementById("mine_field").appendChild(table);
      let num = 1;
      for (let j = 0; j < grid_rows; j++) {
        let tr = document.createElement("tr");
        tr.setAttribute("id", "myTr" + j);
        document.getElementById("myTable").appendChild(tr);
        cell[j] = [];
        for (let i = 0; i < grid_cols; i++) {
          let td = document.createElement("td");
          td.setAttribute("id", "cell_" + j + "-" + i);
          td.setAttribute("data-row", j);
          td.setAttribute("data-col", i);
          cell[j][i] = {
            mine: false,
            //adjacent_mines: null,
            //clicked: null,
            //flagged: null,
          };
          document.getElementById("myTr" + j).appendChild(td);
          num++;
        }
      }
    }
    /**
     * Checks if it is the first click to lay the mines
     */
    function check_first_click(row, col) {
      if (firstClick) {
        lay_mines(row, col)
        firstClick = false
        buscar_minas_adyacentes()
        start_timer()
      }
    }
    /**
     * Busqueda de minas en toda la tabla.
     * Guarda las minas encontradas en una variable
     */
    function buscar_minas_adyacentes() {
      //console.log("buscar_minas_adyacentes, inicio")
      for (let i = 0; i < grid_rows; i++) {
        for (let j = 0; j < grid_cols; j++) {
          cell[i][j].adjacent_mines = mina_adjacente(i, j)
        }
      }
      //console.log("buscar_minas_adyacentes, fin")
    }

    //Busqueda de minas adyacentes alrededor de una celda especifica
    function mina_adjacente(row, col) {
      let mine_counter = 0
      const up_left = () => (cell[row * 1 - 1][col * 1 - 1].mine) ? mine_counter++ : null;
      const up = () => (cell[row * 1 - 1][col].mine) ? mine_counter++ : null;
      const up_right = () => (cell[row * 1 - 1][col * 1 + 1].mine) ? mine_counter++ : null;
      const right = () => (cell[row][col * 1 + 1].mine) ? mine_counter++ : null;
      const down_right = () => (cell[row * 1 + 1][col * 1 + 1].mine) ? mine_counter++ : null;
      const down = () => (cell[row * 1 + 1][col].mine) ? mine_counter++ : null;
      const down_left = () => (cell[row * 1 + 1][col * 1 - 1].mine) ? mine_counter++ : null;
      const left = () => (cell[row][col * 1 - 1].mine) ? mine_counter++ : null;
      if (row == 0 && col == 0) {
        //top left corner
        down()
        down_right()
        right()
      } else if (row == 0 && col == grid_cols * 1 - 1) {
        //top right corner
        left()
        down_left()
        down()
      } else if (row == 0 && col < grid_cols * 1 - 1) {
        //top between corners
        left()
        down_left()
        down()
        down_right()
        right()
      } else if (row < grid_rows * 1 - 1 && col == 0) {
        //left between corners
        up()
        up_right()
        right()
        down_right()
        down()
      } else if (row == grid_rows * 1 - 1 && col == 0) {
        //bottom left corner
        up()
        up_right()
        right()
      } else if (row == grid_rows * 1 - 1 && col < grid_cols * 1 - 1) {
        //bottom between corners
        left()
        up_left()
        up()
        up_right()
        right()
      } else if (row == grid_rows * 1 - 1 && col == grid_cols * 1 - 1) {
        //bottom right corner
        left()
        up_left()
        up()
      } else if (row > 0 && col == grid_cols * 1 - 1) {
        // right between corners
        up()
        up_left()
        left()
        down_left()
        down()
      } else {
        up()
        up_right()
        right()
        down_right()
        down()
        down_left()
        left()
        up_left()
      }
      return mine_counter
    }

    function lay_mines(row, col) {
      //console.log("lay_mines, inicio")
      let counter = 0
      let visual_counter = 0
      let currentCell = document.getElementById("cell_" + row + "-" + col)
      try {
        cell[row][col].safe = true
          //console.log("safe cell is : row col")
          //console.log(row)
          //console.log(col)
      } catch (error) {
        //prevent error display in console
      }
      while (counter < inicial_mines) {
        let i = Math.floor(Math.random() * grid_rows)
        let j = Math.floor(Math.random() * grid_cols)
        if (!cell[i][j].safe) {
          //prevent mines from repeating a cell
          if (!cell[i][j].mine) {
            cell[i][j].mine = true
            counter++
            //mine locations
            console.log("mine location: " + i + "-" + j) //borrar
          }
        }
        visual_counter++
      }
      //console.log("mine counter " + counter) //borrar
      //console.log("lay_mines, fin + visual counter " + visual_counter)
    }
    /**
     * Displays all mines when the user loses
     */
    function display_all_mines() {
      for (let i = 0; i < grid_rows; i++) {
        for (let j = 0; j < grid_cols; j++) {
          if (cell[i][j].mine) {
            let element = document.getElementById("cell_" + i * 1 + "-" + j * 1);
            element.classList.add("mine")
            element.classList.add("bandera")
          }
        }
      }
    }

    /**
     * Displays "Game Over" when the user loses
     */
    function you_lost() {
      display_message("loser")
      disable_table()
    }

    function you_win() {
      display_message("winner");
      disable_table()
    }

    function disable_table() {
      stop_clicks = true
      stop_timer();
    }

    /**
     * Text message displaying function
     */
    function display_message(text, value) {
      switch (text) {
        case "loser":
          document.getElementById("you_lost").innerHTML = "Game Over"
          document.getElementById("myTable").classList.add("border_lost")
          break;
        case "winner":
          document.getElementById("myTable").classList.add("border_won")
          document.getElementById("you_won").innerHTML = "You Won"
          break;
        case "pending":
          document.getElementById("display_mine_pending").innerHTML = value
          break;
        default:
          break;
      }
    }
    //===============================================================




    /**
     * attempt to propagate zeros - //in development
     */
    function count_zero(row, col) {
      row *= 1 //making sure it is a number afterwards
      col *= 1
      var bundle = {}
      let counter = 0
      let control_counter = 0
      let i = j = 0
      let layer = 0

      _find_zeroes_around_cell(row, col)

      console.log("bundle")
      console.log(bundle)

      //longitud de la variable bundle
      let bundle_length = Object.keys(bundle).length

      //no adyacent mines, not clicked, not a mine
      function __is_cell_empty_before_click(row, col) {
        if (!cell[row][col].adjacent_mines && !cell[row][col].clicked && !cell[row][col].mine) {
          return true
        }
      }


      function _find_zeroes_around_cell(row, col) {

        if (!cell[row][col].adjacent_mines) {
          layer++
          row *= 1
          col *= 1

          let _up = row * 1 - 1
          let _left = col * 1 - 1
          let _right = col * 1 + 1
          let _down = row * 1 + 1

          let a = grid_cols * 1 - 1
          let b = grid_rows * 1 - 1

          function set_clicked(row, col) {
            mark_as_clicked(row, col)
          }

          if (row == 0 && col == 0) {
            //top left corner
            down()
            down_right()
            right()
          } else if (row == 0 && col == a) {
            //top right corner
            left()
            down_left()
            down()
          } else if (row == 0 && col < a) {
            //top between corners
            left()
            down_left()
            down()
            down_right()
            right()
          } else if (row < b && col == 0) {
            //left between corners
            up()
            up_right()
            right()
            down_right()
            down()
          } else if (row == b && col == 0) {
            //bottom left corner
            up()
            up_right()
            right()
          } else if (row == b && col < a) {
            //bottom between corners
            left()
            up_left()
            up()
            up_right()
            right()
          } else if (row == b && col == a) {
            //bottom right corner
            left()
            up_left()
            up()
          } else if (row > 0 && col == a) {
            // right between corners
            up()
            up_left()
            left()
            down_left()
            down()
          } else {
            up()
            up_right()
            right()
            down_right()
            down()
            down_left()
            left()
            up_left()
          }

          function up_left() {
            if (!cell[_up][_left].adjacent_mines) {
              set_clicked(_up, _left)
            }
          }

          function up() {
            if (!cell[_up][col].adjacent_mines) {
              set_clicked(_up, col)
            }
          }

          function up_right() {
            if (!cell[_up][_right].adjacent_mines) {
              set_clicked(_up, _right)
            }
          }

          function right() {
            if (!cell[row][_right].adjacent_mines) {
              set_clicked(row, _right)
            }
          }

          function down_right() {
            if (!cell[_down][_right].adjacent_mines) {
              set_clicked(_down, _right)
            }
          }

          function down() {
            if (!cell[_down][col].adjacent_mines) {
              set_clicked(_down, col)
            }
          }

          function down_left() {
            if (!cell[_down][_left].adjacent_mines) {
              set_clicked(_down, _left)
            }
          }

          function left() {
            if (!cell[row][_left].adjacent_mines) {
              set_clicked(row, _left)
            }
          }
        }
      }
    }

    function unique_values(items) {
      //let items_length = Object.keys(items).length
      let d = {}
      let out = []
      for (let i = 0; i < Object.keys(items).length; i++) {
        let item = items[i]
        let rep = item.toString()

        if (!d[rep]) {
          d[rep] = true;
          out.push(item)
        }
      }
      return out
    }

    function mark_as_clicked(row, col) {
      let clicked = document.getElementById("cell_" + row + "-" + col);
      cell[row][col].clicked = true
      clicked.classList.add("clicked")
    }

    /**
     * Left click controls
     */
    document.onclick = (e) => {
      const my_node = document.getElementById('myTable')
      const isClickInside = my_node.contains(e.target)
        //console.log("isClickInside: " + isClickInside + " doc.onclick")
      let row = e.target.dataset.row;
      let col = e.target.dataset.col;
      if (isClickInside && row > -1) {
        //console.log("document.onclick + e.target.dataset.row: " + row) //borrar
        //console.log("document.onclick + e.target.dataset.col: " + col) //borrar
        let clicked = document.getElementById("cell_" + row + "-" + col);
        //Poner minas
        check_first_click(row, col)
        try {
          if (clicked.classList.contains("bandera") || clicked.classList.contains("duda")) {
            e.preventDefault()
          } else {
            //Estoy haciendo click en una mina?
            if (cell[row][col].mine) {
              //muestra todas las minas
              display_all_mines()
              you_lost()
              e.preventDefault()
            } else { //if cell is not a mine
              if (!stop_clicks) {

                //escribir numero de minas adyacentes
                if (cell[row][col].adjacent_mines > 0) {
                  clicked.innerHTML = cell[row][col].adjacent_mines
                } else {
                  count_zero(row, col);
                }
                //Agrega la clase "clicked" a la celda actual y la pone gris
                mark_as_clicked(row, col)

                object_counter()

              } else {
                e.preventDefault()
                disable_table()
              }
            }
          }
        } catch (error) {
          //Preventing the error to be displayed in the console
        }
      }
    }

    /**
     * Right click functions
     */
    document.oncontextmenu = (e) => {
      e.preventDefault()
      let row = e.target.dataset.row;
      let col = e.target.dataset.col;
      let clicked = document.getElementById("cell_" + row + "-" + col);
      try {
        if (!stop_clicks) {
          //si ya ha sido clicked no puede hacer click derecho
          if (!clicked.classList.contains("clicked")) {
            //Intercambio de Bandera por duda
            if (!clicked.classList.contains("bandera") && !clicked.classList.contains("duda")) {
              clicked.classList.toggle("bandera");
              cell[row][col].flagged = true
              object_counter()
            } else if (clicked.classList.contains("bandera")) {
              clicked.classList.remove("bandera")
              cell[row][col].flagged = false
              clicked.classList.toggle("duda");
            } else if (clicked.classList.contains("duda")) {
              clicked.classList.remove("duda")
              object_counter()
            }
          }
        } else {
          e.preventDefault()
          disable_table()
        }
      } catch (error) {
        //Preventing the error to be displayed in the console
        //document.getElementById("error").innerHTML = "oncontextmenu: \n"+error
      }
    }
  </script>
</body>

</html>