<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> Mine Sweeper </title>
  <style>
    * {
      -khtml-user-select: none;
      -o-user-select: none;
      -moz-user-select: -moz-none;
      -webkit-user-select: none;
      user-select: none;
    }
    
    body {
      font-size: 12px;
      text-align: center;
      font-family: 'Lucida Grande', Verdana, 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Sans Unicode', Geneva, sans-serif;
      background: linear-gradient(to right, ivory, snow);
      /* background: linear-gradient(to right, antiquewhite, beige, cornsilk, ivory, bisque); */
    }
    
    h1 {
      font-size: 3rem;
      font-weight: bolder;
      margin-top: .3rem;
      margin-bottom: .3rem;
      text-shadow: 2px 2px 2px rgb(139, 131, 131), 3px 3px 5px rgb(133, 125, 123);
    }
    
    table {
      margin: auto;
      border: 1px solid rgb(127, 127, 127);
    }
    
    td {
      height: 1.1rem;
      width: 1.1rem;
      background-color: #ccc;
      border-left: .2rem solid #fafafa;
      border-top: .2rem solid #fafafa;
      border-right: .2rem solid #aaa;
      border-bottom: .2rem solid #aaa;
      font-weight: 900;
      font-size: .8rem;
      border-spacing: 0;
      border-collapse: none;
    }
    
    .clicked {
      border: .2rem solid #e6e1e1;
      background-color: #eee;
      color: #666666;
      animation: fadein .35s;
    }
    
    .mine {
      background-color: cornflowerblue;
      animation: fadein .35s;
    }
    
    .mineLost {
      background-color: crimson;
      animation: fadein .35s;
      color: #4e4343;
    }
    
    .fakeMine {
      background-color: #f5f050;
      animation: fadein .35s;
    }
    
    .modeArea {
      margin: auto;
      border: 1px solid black;
      border-radius: 7px;
      padding: 1rem;
      max-width: fit-content;
    }
    
    .text {
      font-size: 1.2rem;
      font-weight: bolder;
    }
    
    .crimson {
      color: crimson;
    }
    
    .flag:before {
      font-size: .8rem;
      content: "\2691";
      /*   âš‘ - taken from https://www.compart.com/en/unicode/U+2691 */
      animation: fadein .5s;
      /* color: crimson; */
    }
    
    .hesitation:before {
      font-size: .8rem;
      content: "?";
      animation: fadein .5s;
      color: crimson;
    }
    
    #youLost {
      font-size: 1.7rem;
      font-weight: bolder;
      color: crimson;
      animation: fadein 1s;
    }
    
    #youWon {
      font-size: 3rem;
      font-weight: bolder;
      color: blue;
      animation: fadein .5s;
    }
    
    @keyframes fadein {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    
    .button {
      padding: 5px 10px;
      font-size: 1.2rem;
      text-align: center;
      cursor: pointer;
      outline: none;
      color: #000000;
      background-color: #e9c581;
      border: none;
      border-radius: 5px;
      box-shadow: 0 6px #999;
    }
    
    .button:hover {
      background-color: #eea333
    }
    
    .buttonPressed {
      background-color: #3b3534;
      color: #e9e4e4;
      border: 2px solid coral;
      /* transform: translateY(4px);
        box-shadow: 0 2px #999; */
    }
    
    .borderGameWon {
      border: 1rem solid blue;
    }
    
    .borderGameLost {
      border: .3rem solid red;
    }
  </style>
</head>

<body>
  <h1>Mine Sweeper </h1>
  <h3>&#9873; : mines
    <!-- &emsp;&emsp; ? : marker -->
  </h3>
  <br>
  <p class="">
    <span id="displayMinePending" class="text crimson modeArea"></span> &emsp;&emsp;
    <span id="elapsedTime" class="text crimson modeArea">0:00</span>
  </p>
  <br>
  <section id="mineField"></section>
  <br>
  <section class="modeArea">
    <!-- <div class="text">Mode</div>
    <br>-->
    <button class="button" id="button1" onclick="reset(1)">Easy</button>
    <button class="button" id="button2" onclick="reset(2)">Medium</button>
    <button class="button" id="button3" onclick="reset(3)">Hard</button>
  </section>
  <br>
  <br>
  <section id="youWon"></section>
  <section id="youLost"></section>
  <section id="error">
    <ul></ul>
  </section>
  <script type="text/javascript">
    /**
     * Mine sweeper game. Beta version 2.0.1
     */

    var gridCols = 11
    var gridRows = 11
    var initialMines = 1 //

    const cell = []
    var firstClick = true;
    var stopClicks = false

    //developer mode
    if (1) {
      reset(1)
    } else {
      createBoard()
    }

    //Time variables
    var myInterval = null;
    var seconds = 0
    var minutes = 0;

    //time functions
    function startTimer() {
      myInterval = setInterval(myTimer, 1000);
    }

    function myTimer() {
      if (seconds < 10) {
        seconds = "0" + seconds
      }
      if (seconds > 59) {
        minutes++
        seconds = "00"
      }
      document.getElementById("elapsedTime").innerHTML = minutes + ":" + seconds
      seconds++
    }

    function stopTimer() {
      clearInterval(myInterval);
    }
    /**
     * Lever reset
     * param: integer, changes de level of difficulty
     */
    function reset(level) {
      seconds = 0;
      minutes = 0;
      document.getElementById("displayMinePending").innerHTML = 0;
      document.getElementById("elapsedTime").innerHTML = "0:00";

      const table = document.getElementById("myTable");
      if (table) {
        table.remove();
      }

      const removeClass = document.getElementsByClassName("buttonPressed");
      if (removeClass.length > 0) {
        removeClass[0].classList.remove("buttonPressed");
      }

      firstClick = true;
      stopClicks = false;
      let button = null;

      if (level == 1) {
        gridRows = 9;
        gridCols = 9;
        initialMines = 10;
        button = document.getElementById("button1");
      } else if (level == 2) {
        gridRows = 16;
        gridCols = 16;
        initialMines = 40;
        button = document.getElementById("button2");
      } else if (level == 3) {
        gridRows = 16;
        gridCols = 30;
        initialMines = 99;
        button = document.getElementById("button3");
      }

      stopTimer();
      createBoard(gridRows, gridCols);
      button.classList.add("buttonPressed");

      displayMessage("pending", initialMines);
      document.getElementById("youLost").innerHTML = "";
      document.getElementById("youWon").innerHTML = "";
    }

    /**
     * Counts the values of the array "cell"
     */
    function objectCounter() {
      let countFlags = 0;
      let countMines = 0;
      let countMinePlusFlags = 0;
      let countClicked = 0;

      for (let i = 0; i < gridRows; i++) {
        for (let j = 0; j < gridCols; j++) {
          if (cell[i][j].mine && cell[i][j].flagged) {
            countMinePlusFlags++;
          }
          if (cell[i][j].flagged) {
            countFlags++;
          }
          if (cell[i][j].mine) {
            countMines++;
          }
          if (cell[i][j].clicked) {
            countClicked++;
          }
        }
      }

      displayMessage("pending", (initialMines - countFlags));

      if (
        countMinePlusFlags === countFlags &&
        countFlags === countMines &&
        (countFlags + countClicked) === gridRows * gridCols &&
        countMines !== 0
      ) {
        youWin();
      }
    }

    /**
     * Creates the initial board and when changing levels of difficulty
     */
    function createBoard() {
      const table = document.createElement("table");
      table.id = "myTable";
      document.getElementById("mineField").appendChild(table);

      for (let j = 0; j < gridRows; j++) {
        const tr = document.createElement("tr");
        tr.id = "myTr" + j;
        document.getElementById("myTable").appendChild(tr);
        cell[j] = [];

        for (let i = 0; i < gridCols; i++) {
          const td = document.createElement("td");
          td.id = "cell_" + j + "-" + i;
          td.dataset.row = j;
          td.dataset.col = i;
          cell[j][i] = {
            mine: false,
            //adjacentMines: null,
            //clicked: null,
            //flagged: null,
          };
          document.getElementById("myTr" + j).appendChild(td);
        }
      }
    }

    /**
     * Checks if it is the first click to lay the mines
     */
    function checkFirstClick(row, col) {
      if (firstClick) {
        layMines(row, col)
        firstClick = false
        searchAdjacentMines()
        startTimer()
      }
    }

    /**
     * Search for mines throughout the table
     * It stores the mines it finds in a variable
     */
    function searchAdjacentMines() {
      for (let i = 0; i < gridRows; i++) {
        for (let j = 0; j < gridCols; j++) {
          cell[i][j].adjacentMines = _adjacentMines(i, j);
        }
      }
    }

    /**
     * Search for adjacent mines sourrounding a specific cell
     */
    function _adjacentMines(row, col) {
      let mineCounter = 0;

      const checkAdjacentCell = (r, c) => {
        if (cell[r][c].mine) mineCounter++;
      };

      const upLeft = () => checkAdjacentCell(row - 1, col - 1);
      const up = () => checkAdjacentCell(row - 1, col);
      const upRight = () => checkAdjacentCell(row - 1, col + 1);
      const right = () => checkAdjacentCell(row, col + 1);
      const downRight = () => checkAdjacentCell(row + 1, col + 1);
      const down = () => checkAdjacentCell(row + 1, col);
      const downLeft = () => checkAdjacentCell(row + 1, col - 1);
      const left = () => checkAdjacentCell(row, col - 1);

      if (row === 0 && col === 0) {
        //top left corner
        down();
        downRight();
        right();
      } else if (row === 0 && col === gridCols - 1) {
        //top right corner
        left();
        downLeft();
        down();
      } else if (row === 0 && col < gridCols - 1) {
        //top between corners
        left();
        downLeft();
        down();
        downRight();
        right();
      } else if (row < gridRows - 1 && col === 0) {
        //left between corners
        up();
        upRight();
        right();
        downRight();
        down();
      } else if (row === gridRows - 1 && col === 0) {
        //bottom left corner
        up();
        upRight();
        right();
      } else if (row === gridRows - 1 && col < gridCols - 1) {
        //bottom between corners
        left();
        upLeft();
        up();
        upRight();
        right();
      } else if (row === gridRows - 1 && col === gridCols - 1) {
        //bottom right corner
        left();
        upLeft();
        up();
      } else if (row > 0 && col === gridCols - 1) {
        // right between corners
        up();
        upLeft();
        left();
        downLeft();
        down();
      } else {
        up();
        upRight();
        right();
        downRight();
        down();
        downLeft();
        left();
        upLeft();
      }

      return mineCounter;
    }


    /**
     * Lay the mines after the first click
     */
    function layMines(row, col) {
      let counter = 0;
      let currentCell = document.getElementById("cell_" + row + "-" + col);

      try {
        cell[row][col].safe = true;
      } catch (error) {
        // prevent error from showing in the console
      }

      let tempNumber1 = 0
      let tempNumber2 = 0
      let i = 0;
      let j = 0;
      let tempCounter = 0;
      while (counter < initialMines) {


        do {
          i = Math.floor(Math.random() * gridRows);
        } while (tempNumber1 === i)

        do {
          j = Math.floor(Math.random() * gridCols);
          console.log(tempCounter++)
        } while (tempNumber2 === j)

        tempNumber1 = i;
        tempNumber2 = j;

        if (!cell[i][j].safe && !cell[i][j].mine) {
          cell[i][j].mine = true;
          counter++;
        }
      }
    }


    /**
     * Displays all mines when the user loses in different colors
     * Yellow for mines you clicked that are not really mines
     * Red for the mines you did not click
     * Blue for the mines you clicked
     */
    function displayAllMines() {
      for (let i = 0; i < gridRows; i++) {
        for (let j = 0; j < gridCols; j++) {
          let element = document.getElementById("cell_" + i + "-" + j);

          if (!cell[i][j].mine && element.classList.contains("flag")) {
            element.classList.add("fakeMine"); //yellow
            element.classList.add("flag");
          } else if (cell[i][j].mine && !element.classList.contains("flag")) {
            element.classList.add("mineLost"); //red
            element.classList.add("flag");
          } else if (cell[i][j].mine) {
            element.classList.add("mine"); // blue
            element.classList.add("flag");
          }
        }
      }
    }


    /**
     * Displays "Game Over" when the user loses 
     * prevent anymore clicks on the table 
     */
    function youLost() {
      displayMessage("loser")
      disableTable()
    }

    /**
     * Displays "Winner" when the user wins 
     * prevent anymore clicks on the table 
     */
    function youWin() {
      displayMessage("winner");
      disableTable()
    }

    /**
     * Stops the timer and activates the variable to stop clicks
     */
    function disableTable() {
      stopClicks = true
      stopTimer();
    }

    /**
     * Text message displaying function
     */
    function displayMessage(text, value) {
      const youLostElement = document.getElementById("youLost");
      const youWonElement = document.getElementById("youWon");
      const tableElement = document.getElementById("myTable");
      const minePendingElement = document.getElementById("displayMinePending");

      switch (text) {
        case "loser":
          youLostElement.innerHTML = "Game Over";
          tableElement.classList.add("borderGameLost");
          break;
        case "winner":
          tableElement.classList.add("borderGameWon");
          youWonElement.innerHTML = "You Won";
          break;
        case "pending":
          minePendingElement.innerHTML = value;
          break;
        default:
          break;
      }
    }


    /**
     * Marks the current cell as "clicked"
     */
    function markAsClicked(row, col) {
      const clickedCell = document.getElementById("cell_" + row + "-" + col);
      cell[row][col].clicked = true;
      clickedCell.classList.add("clicked");
    }

    /**
     * Writes the adjacent mines around a specific cell
     */
    function writeAdjacentMines(row, col) {
      const clickedCell = document.getElementById("cell_" + row + "-" + col);
      const adjacentMines = cell[row][col].adjacentMines;
      if (adjacentMines > 0) {
        clickedCell.innerHTML = adjacentMines;
      }
    }


    //===============================================================

    /**
     * Propagates clicks on cells that have no adjacent mines
     */
    function countZero(row, col) {
      row = Number(row);
      col = Number(col);

      let adjacentCells = getAdjacentCells(row, col);

      let zerosAndGreater = adjacentCells.filter(function(coord) {
        let row = coord[0];
        let column = coord[1];
        return cell[row][column] === 0 || cell[row][column] > 0;
      });

      for (let i = 0; i < adjacentCells.length; i++) {
        let row = adjacentCells[i][0];
        let column = adjacentCells[i][1];
        writeAdjacentMines(row, column);
        markAsClicked(row, column);
      }
    }

    /** 
     * Get the coordinates of adjacent cells 
     */
    function getAdjacentCells(row, column) {
      let adjacentCells = [];
      let visited = new Set();

      /**
       * Check if a cell has been visited
       */
      function isCellVisited(row, column) {
        return visited.has(`${row},${column}`);
      }
      /**
       * Mark a cell as visited
       */
      function markCellAsVisited(row, column) {
        visited.add(`${row},${column}`);
      }

      /**
       * Relative coordinates of adjacent cells (left, top, right, bottom)
       */
      let directions = [
        [0, -1], // left
        [-1, 0], // top
        [0, 1], // right
        [1, 0], // bottom
        [-1, -1], // top left
        [-1, 1], // top right
        [1, -1], // bottom left
        [1, 1] // bottom right
      ];

      /**
       * Function to recursively search for adjacent cells
       */
      function searchAdjacentCellsRecursive(row, column) {
        if (isCellVisited(row, column)) {
          return;
        }

        markCellAsVisited(row, column);
        adjacentCells.push([row, column]);

        // Iterate over the adjacent directions
        for (let i = 0; i < directions.length; i++) {
          let direction = directions[i];
          let adjacentRow = row + direction[0];
          let adjacentColumn = column + direction[1];

          // Check if the adjacent cell is within the grid limits
          if (adjacentRow >= 0 && adjacentRow < gridRows && adjacentColumn >= 0 && adjacentColumn < gridCols) {

            // Check if the adjacent cell is a zero
            if (cell[adjacentRow][adjacentColumn].adjacentMines === 0) {
              searchAdjacentCellsRecursive(adjacentRow, adjacentColumn);
            } else {
              // If the adjacent cell has a number greater than zero, stop exploring further
              adjacentCells.push([adjacentRow, adjacentColumn]);
            }
          }
        }
      }

      // Check if the initial coordinates are valid
      if (
        row >= 0 &&
        row < gridRows &&
        column >= 0 &&
        column < gridCols
      ) {
        // Search for adjacent cells starting from the given coordinates
        searchAdjacentCellsRecursive(row, column);
      }

      return adjacentCells;
    }

    /**
     * Left click controls
     */
    document.onclick = (e) => {
      const myNode = document.getElementById('myTable');
      const isClickInside = myNode.contains(e.target);

      let row = e.target.dataset.row;
      let col = e.target.dataset.col;
      row = Number(row);
      col = Number(col);

      if (isClickInside && row > -1) {
        let clicked = document.getElementById("cell_" + row + "-" + col);

        checkFirstClick(row, col);

        try {
          if (clicked.classList.contains("flag") || clicked.classList.contains("hesitation")) {
            e.preventDefault();
          } else {
            if (cell[row][col].mine) {
              displayAllMines();
              youLost();
              e.preventDefault();
            } else {
              if (!stopClicks) {
                if (cell[row][col].adjacentMines > 0) {
                  writeAdjacentMines(row, col);
                } else {
                  countZero(row, col);
                }
                markAsClicked(row, col);
                objectCounter();
              } else {
                e.preventDefault();
                disableTable();
              }
            }
          }
        } catch (error) {
          // Prevent errors from showing in the console
        }
      }
    };


    /**
     * Right click functions
     */
    document.oncontextmenu = (e) => {
      e.preventDefault();
      let row = e.target.dataset.row;
      let col = e.target.dataset.col;
      let clicked = document.getElementById("cell_" + row + "-" + col);

      try {
        if (!stopClicks) {
          if (!clicked.classList.contains("clicked")) {
            if (!clicked.classList.contains("flag") && !clicked.classList.contains("hesitation")) {
              clicked.classList.toggle("flag");
              cell[row][col].flagged = true;
              objectCounter();
            } else if (clicked.classList.contains("flag")) {
              clicked.classList.remove("flag");
              cell[row][col].flagged = false;
              clicked.classList.toggle("hesitation");
            } else if (clicked.classList.contains("hesitation")) {
              clicked.classList.remove("hesitation");
              objectCounter();
            }
          }
        } else {
          e.preventDefault();
          disableTable();
        }
      } catch (error) {
        // Prevent errors from showing in the console
      }
    };
  </script>
</body>

</html>